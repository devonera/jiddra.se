var data = (function () {
  var fn = {};

  fn.init = function(root) {
    fn.root = root;
    fn.collection = {};
    fn.selectors();

    Object.keys(fn.selector).forEach(function(key) {
      fn.get(key);
      fn.trigger(key);
    });

    fn.collection = Object.assign({}, fn.collection);
    fn.ajax();
  };

  fn.selectors = function() {
    fn.selector = {};
    fn.selector['range'] = '.form input[type="range"]';
    fn.selector['checkbox'] = '.form .checkboxes input[type="checkbox"]';
    fn.selector['select'] = '.form .selectboxes select';
  };

  fn.go = function() {
    fn.collection = [];
    Object.keys(fn.selector).forEach(function(key) {
      fn.get(key);
    });

    fn.collection = Object.assign({}, fn.collection);

    fn.ajax();
  };

  fn.get = function(type) {
    var selector = fn.selector[type];
    var items = document.querySelectorAll(selector);
    for(i = 0; i<items.length; i++) {
      var item = items[i];
      fn.collection[item.getAttribute('name')] = window.data[type](item);
    }
  };

  fn.ajax = function() {
    var json = JSON.stringify(fn.collection);

    console.log(fn.root);

    fetch(fn.root + '/lan-api', {
      method: 'POST',
      body: json,
      headers: {
        "Content-Type": "Content-Type: application/json"
    },
    }).then(function(response) {
      return response.text();
    }).then(function(text) { 
      document.querySelector('.results').innerHTML = text;
      window.initEasyToggleState();
    });
  };

  fn.range = function(item) {
    return item.value;
  };

  fn.checkbox = function(item) {
    return item.checked;
  };

  fn.select = function(item) {
    return item.options[item.selectedIndex].value;
  };

  fn.reset = function() {
    fn.selectors();
    var checkboxes = document.querySelectorAll(fn.selector['checkbox']);
    var selects = document.querySelectorAll(fn.selector['select']);

    for(i=0; i<checkboxes.length; i++) {
      checkboxes[i].checked = false;
    }

    for(i=0; i<selects.length; i++) {
      var current = selects[i];
      var group = current.previousElementSibling;
      var button = group.querySelector('button');
      var list_item_current = group.querySelector('[data-index="' + current.selectedIndex +  '"]');
      var list_item_first = group.querySelector('[data-index="0"]').innerHTML;
      button.innerHTML = list_item_first;
      list_item_current.classList.remove('is-selected');

      current.selectedIndex = 0;
    }
  };

  fn.trigger = function(type) {
    var selector = fn.selector[type];
    var items = document.querySelectorAll(selector);

    for(i = 0; i<items.length; i++) {
      items[i].onchange = function() {
        fn.go();
      };
    }
  };
  
	return fn;
})();
; // jshint ignore:line
(function (root, factory, undefined) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    // root is window
    root.CookiesEuBanner = factory();
  }
}(window, function () {
  'use strict';

  var CookiesEuBanner,
    document = window.document;

  CookiesEuBanner = function (launchFunction, waitAccept, undefined) {
    if (!(this instanceof CookiesEuBanner)) {
      return new CookiesEuBanner(launchFunction);
    }

    this.cookieTimeout = 33696000000; // 13 months in milliseconds
    this.bots = /bot|googlebot|crawler|spider|robot|crawling/i;
    this.cookieName = 'hasConsent';
    this.trackingCookiesNames = [ '__utma', '__utmb', '__utmc', '__utmt', '__utmv', '__utmz', '_ga', '_gat', '_gid' ];
    this.launchFunction = launchFunction;
    this.waitAccept = waitAccept || false;
    this.init();
  };

  CookiesEuBanner.prototype = {
    init: function () {
      // Do nothing if it is a bot
      // If DoNotTrack is activated, do nothing too
      if (this.isBot() || !this.isToTrack() || this.hasConsent() === false) {
        return false;
      }

      // User has already consent to use cookies to tracking
      if (this.hasConsent() === true) {
        // Launch user custom function
        this.launchFunction();
        return true;
      }

      // If it's not a bot, no DoNotTrack and not already accept : show banner
      this.showBanner();

      if (!this.waitAccept) {
        // Accept cookies by default for the next page
        this.setCookie(this.cookieName, true);
      }
    },

    /*
     * Show banner at the top of the page
     */
    showBanner: function () {
      var _this = this,
        banner = document.getElementById('cookies-eu-banner'),
        rejectButton = document.getElementById('cookies-eu-reject'),
        acceptButton = document.getElementById('cookies-eu-accept'),
        moreLink = document.getElementById('cookies-eu-more'),
        waitRemove = (banner.dataset.waitRemove === undefined) ? 0 : parseInt(banner.dataset.waitRemove); 

      banner.style.display = 'block';

      if (moreLink) {
        this.addEventListener(moreLink, 'click', function () {
          _this.deleteCookie(_this.cookieName);
        });
      }

      if (acceptButton) {
        this.addEventListener(acceptButton, 'click', function () {
          _this.removeBanner(banner, waitRemove);
          _this.setCookie(_this.cookieName, true);
          _this.launchFunction();
        });
      }

      if (rejectButton) {
        this.addEventListener(rejectButton, 'click', function () {
          _this.removeBanner(banner, waitRemove);
          _this.setCookie(_this.cookieName, false);
          _this.deleteTrackingCookies();
        });
      }
    },

    /*
     * Check if user already consent
     */
    hasConsent: function () {
      if (document.cookie.indexOf(this.cookieName + '=true') > -1) {
        return true;
      } else if (document.cookie.indexOf(this.cookieName + '=false') > -1) {
        return false;
      }

      return null;
    },

    /*
     * Detect if the visitor is a bot or not
     * Prevent for search engine take the cookie
     * alert message as main content of the page
     */
    isBot: function () {
      return this.bots.test(navigator.userAgent);
    },

    /*
     * Check if DoNotTrack is activated
     */
    isToTrack: function () {
      var dnt = navigator.doNotTrack || navigator.msDoNotTrack || window.doNotTrack;
      return (dnt !== null && dnt !== undefined) ? (dnt && dnt !== 'yes' && dnt !== 1 && dnt !== '1') : true;
    },

    /*
     * Delete existent tracking cookies
     */
    deleteTrackingCookies: function () {
      var _this = this;
      this.trackingCookiesNames.map(function (cookieName) {
        _this.deleteCookie(cookieName);
      });
    },

    /*
     * Create/update cookie
     */
    setCookie: function (name, value) {
      var date = new Date();
      date.setTime(date.getTime() + this.cookieTimeout);

      document.cookie = name + '=' + value + ';expires=' + date.toGMTString() + ';path=/';
    },

    /*
     * Delete cookie by changing expire
     */
    deleteCookie: function (name) {
      var hostname = document.location.hostname;
      if (hostname.indexOf('www.') === 0) {
        hostname = hostname.substring(4);
      }
      document.cookie = name + '=; domain=.' + hostname + '; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/';
      document.cookie = name + '=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/';
    },

    addEventListener: function (DOMElement, evnt, callback) {
      if (document.addEventListener) { // For all major browsers, except IE 8 and earlier
        DOMElement.addEventListener(evnt, callback);
      } else if (DOMElement.attachEvent) { // For IE 8 and earlier versions
        DOMElement.attachEvent('on' + evnt, callback);
      }
    },

    /*
     * Delays removal of banner allowing developers
     * to specify their own transition effects
     */
    removeBanner: function (banner, wait) {
      setTimeout (function() {
        banner.parentNode.removeChild(banner);
      }, wait);
    }
  };

  return CookiesEuBanner;
}));
var TinyDrawer = (function () {
  var fn = {};
  var o = {};

  fn.init = function(options) {
    o = Object.assign({}, fn.defaults(), options);

    document.addEventListener("DOMContentLoaded", function(event) {
      fn.backdropAdd();
      fn.setup();

      fn.triggerOpen();
      fn.triggerClose();
    });
  };

  // Defaults
  fn.defaults = function() {
    return {
      replacement: 'drawer',
      drawerSelector: 'drawer-menu'
    };
  };

  // Setup
  fn.setup = function() {
    fn.elementDrawer = document.querySelector(o.drawerSelector);
    fn.elementOpen = document.querySelectorAll('[data-' + o.replacement + '-open]');
    fn.elementClose = document.querySelectorAll('[data-' + o.replacement + '-backdrop], [data-' + o.replacement + '-close]');
  };

  // Trigger open
  fn.triggerOpen = function() {
    for(i=0; i<fn.elementOpen.length; i++) {
      fn.elementOpen[i].addEventListener('click', fn.open.bind(null, fn.elementOpen[i]), false);
    }
  };

  // Trigger close
  fn.triggerClose = function() {
    for(i=0; i<fn.elementClose.length; i++) {
      fn.elementClose[i].addEventListener('click', fn.close.bind(null, fn.elementClose[i]), false);
    }
  };

  // Active unset
  fn.activeUnset = function() {
    delete document.body.dataset[o.replacement];
  };

  // Active set
  fn.activeSet = function() {
    document.body.dataset[o.replacement] = true;
  };

  // Offset top to variable
  fn.offsetTopToVariable = function() {
    var offsets = document.body.getBoundingClientRect();
    fn.top = -offsets.top;
  };

  // Open
  fn.open = function(element = null) {
    fn.activeSet();
    fn.offsetTopToVariable();
    fn.callback(element);
  };

  // Close
  fn.close = function(element = null) {
    fn.activeUnset();
    window.scrollTo(0, fn.top);
    fn.callback(element);
  };

  // Backdrop add
  fn.backdropAdd = function() {
    let backdrop = document.createElement('div');
    backdrop.dataset[o.replacement + 'Backdrop'] = '';

    document.body.appendChild(backdrop);
  };

  // Callback init
  fn.callback = function(element) {
    if(typeof o.callback == 'undefined') return;
    if(element === null) return;

    var action = "drawerOpen" in element.dataset ? 'open' : 'close';

    o.callback(element, action);
  };

  return fn;
})();
var affiliateBeautifier = (function () {
	var fn = {};
	var href = '';
	var data_href = '';
	var elements = '';

	fn.init = function(data) {
		fn.elements = document.querySelectorAll(data.selector);
		fn.event();
		fn.switch(data);
	};

	// Switch urls
	fn.switch = function() {
		[].forEach.call(fn.elements, function(e) {
			fn.get(e);
			fn.set(e);
		});
	};

	// Event
	fn.event = function() {
		['mousedown', 'touchstart'].forEach(function(event) {
			fn.elements.forEach(function(element) {
				element.addEventListener(event, function(e) {
					element.setAttribute('href', element.getAttribute('data-href') );
				});

			});
		});
	};

	// Get
	fn.get = function(e) {
		fn.getHref(e);
		fn.getDataHref(e);
	};

	// Set
	fn.set = function(e) {
		fn.setHref(e);
		fn.setDataHref(e);
	}

	// Get href
	fn.getHref = function(e) {
		fn.href = e.getAttribute('href');
	};

	// Get data href
	fn.getDataHref = function(e) {
		var data_href = e.getAttribute('data-href');
		fn.data_href = ( Boolean( data_href ) ) ? data_href : fn.href;
	};

	// Set href
	fn.setHref = function(e) {
		e.setAttribute('href', fn.data_href);

	};

	// Set data href
	fn.setDataHref = function(e) {
		e.setAttribute('data-href', fn.href);
	};

	return fn;
})();
/**
 * -------------------------------------------------------------------
 * easy-toggle-state
 * A tiny JavaScript library to easily toggle the state of any HTML element in any contexts.
 *
 * @author Matthieu Bué <https://twikito.com>
 * @version v1.9.2
 * @link https://twikito.github.io/easy-toggle-state/
 * @license MIT : https://github.com/Twikito/easy-toggle-state/blob/master/LICENSE
 * -------------------------------------------------------------------
 */

(function () {
  'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  /**
   * Prefix set to all attributes.
   */
  var PREFIX = document.documentElement.getAttribute("data-easy-toggle-state-custom-prefix") || "toggle";
  var getPrefix = function getPrefix() {
    return PREFIX;
  };

  /**
   * Retrieve a valid HTML attribute string.
   * @param {string} key - A string to build a html attribute
   * @param {string} prefix - The prefix maybe set by user
   * @returns {string} - A valid html attribute
   */

  var dataset = function dataset(key) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getPrefix();
    return ["data", prefix, key].filter(Boolean).join("-");
  };
  /**
   * All constants containing HTML attributes string.
   */


  var ARROWS = dataset("arrows"),
      CHECKED = "aria-checked",
      CLASS = dataset("class"),
      ESCAPE = dataset("escape"),
      EVENT = dataset("event"),
      EXPANDED = "aria-expanded",
      GROUP = dataset("group"),
      HIDDEN = "aria-hidden",
      IS_ACTIVE = dataset("is-active"),
      OUTSIDE = dataset("outside"),
      RADIO_GROUP = dataset("radio-group"),
      SELECTED = "aria-selected",
      TARGET = dataset("target"),
      TARGET_ALL = dataset("target-all"),
      TARGET_NEXT = dataset("target-next"),
      TARGET_ONLY = dataset("target-only"),
      TARGET_PARENT = dataset("target-parent"),
      TARGET_PREVIOUS = dataset("target-previous"),
      TARGET_SELF = dataset("target-self"),
      TARGET_STATE = dataset("state"),
      TRIGGER_OFF = dataset("trigger-off");

  /**
   * Hooks
   */
  var TOGGLE_AFTER = new Event("toggleAfter"),
      TOGGLE_BEFORE = new Event("toggleBefore");

  /**
   * Retrieve all trigger elements with a specific attribute, or all nodes in a specific scope.
   * @param {string} selector - A string that contains a selector
   * @param {node} [node] - An element in which to make the selection
   * @returns {array} - An array of elements
   */

  var $$ = (function (selector, node) {
    var scope = selector ? "[".concat(selector, "]") : "";
    return node ? _toConsumableArray(node.querySelectorAll(scope)) : _toConsumableArray(document.querySelectorAll("[".concat(CLASS, "]").concat(scope).trim()));
  });

  /**
   * Dispatch hooks
   * @param {node} element - An element on which dispatch the hook
   * @param {string} action - An event to dispatch
   * @returns {boolean} - True or False
   */
  var dispatchHook = (function (element, action) {
    return element.dispatchEvent(action);
  });

  /**
   * Aria attributes toggle manager.
   * @param {node} element - Current element with aria attributes to manage.
   * @param {json} [config] - List of aria attributes and value to assign.
   * @returns {undefined}
   */

  var manageAria = (function (element) {
    var _ref;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_ref = {}, _defineProperty(_ref, CHECKED, element.isToggleActive), _defineProperty(_ref, EXPANDED, element.isToggleActive), _defineProperty(_ref, HIDDEN, !element.isToggleActive), _defineProperty(_ref, SELECTED, element.isToggleActive), _ref);
    return Object.keys(config).forEach(function (key) {
      return element.hasAttribute(key) && element.setAttribute(key, config[key]);
    });
  });

  /**
   * Retrieve all active elements of a group.
   * @param {node} element - An element of a group
   * @returns {array} - An array of active elements of a group
   */

  var retrieveGroupActiveElement = (function (element) {
    var type = element.hasAttribute(GROUP) ? GROUP : RADIO_GROUP;
    return $$("".concat(type, "=\"").concat(element.getAttribute(type), "\"")).filter(function (groupElement) {
      return groupElement.isToggleActive;
    });
  });

  /**
   * Test a targets list.
   * @param {string} selector - The selector corresponding to the targets list
   * @param {nodeList} targetList - A target elements list
   * @returns {nodeList} - The targets list
   */

  var testTargets = function testTargets(selector, targetList) {
    /** Test if there's no match for a selector */
    if (targetList.length === 0) {
      console.warn("There's no match for the selector '".concat(selector, "' for this trigger"));
      return [];
    }
    /** Test if there's more than one match for an ID selector */


    var matches = selector.match(/#\w+/gi);

    if (matches) {
      matches.forEach(function (match) {
        var result = _toConsumableArray(targetList).filter(function (target) {
          return target.id === match.slice(1);
        });

        if (result.length > 1) {
          console.warn("There's ".concat(result.length, " matches for the selector '").concat(match, "' for this trigger"));
        }
      });
    }

    return _toConsumableArray(targetList);
  };
  /**
   * Retrieve all targets of a trigger element, depending of its target attribute.
   * @param {node} element - A trigger element
   * @returns {nodeList} - All targets of a trigger element
   */


  var retrieveTargets = (function (element) {
    if (element.hasAttribute(TARGET) || element.hasAttribute(TARGET_ALL)) {
      var selector = element.getAttribute(TARGET) || element.getAttribute(TARGET_ALL);
      return testTargets(selector, document.querySelectorAll(selector));
    }

    if (element.hasAttribute(TARGET_PARENT)) {
      var _selector = element.getAttribute(TARGET_PARENT);

      return testTargets(_selector, element.parentElement.querySelectorAll(_selector));
    }

    if (element.hasAttribute(TARGET_SELF)) {
      var _selector2 = element.getAttribute(TARGET_SELF);

      return testTargets(_selector2, element.querySelectorAll(_selector2));
    }

    if (element.hasAttribute(TARGET_PREVIOUS)) {
      return testTargets("previous", [element.previousElementSibling].filter(Boolean));
    }

    if (element.hasAttribute(TARGET_NEXT)) {
      return testTargets("next", [element.nextElementSibling].filter(Boolean));
    }

    return [];
  });

  /**
   * Toggle off all elements width 'data-toggle-outside' attribute
   * when reproducing specified or click event outside itself or its targets.
   * @param {event} event - Event triggered on document
   * @returns {undefined}
   */

  var documentEventHandler = function documentEventHandler(event) {
    var target = event.target;

    if (target.closest("[" + TARGET_STATE + '="true"]')) {
      return;
    }

    $$(OUTSIDE).forEach(function (element) {
      if (element !== target && element.isToggleActive) {
        (element.hasAttribute(GROUP) || element.hasAttribute(RADIO_GROUP) ? manageGroup : manageToggle)(element);
      }
    });

    if (target.hasAttribute(OUTSIDE) && target.isToggleActive) {
      document.addEventListener(target.getAttribute(EVENT) || "click", documentEventHandler, false);
    }
  };
  /**
   * Manage click on elements with 'data-trigger-off' attribute.
   * @param {event} event - Event triggered on element with 'trigger-off' attribute
   * @returns {undefined}
   */


  var triggerOffHandler = function triggerOffHandler(event) {
    return manageToggle(event.currentTarget.targetElement);
  };
  /**
   * Manage event ouside trigger or target elements.
   * @param {node} element - The element to toggle when 'click' or custom event is triggered on document
   * @returns {undefined}
   */


  var manageTriggerOutside = function manageTriggerOutside(element) {
    if (!element.hasAttribute(OUTSIDE)) {
      return;
    }

    if (element.hasAttribute(RADIO_GROUP)) {
      return console.warn("You can't use '".concat(OUTSIDE, "' on a radio grouped trigger"));
    }

    if (element.isToggleActive) {
      return document.addEventListener(element.getAttribute(EVENT) || "click", documentEventHandler, false);
    }

    return document.removeEventListener(element.getAttribute(EVENT) || "click", documentEventHandler, false);
  };
  /**
   * Manage elements inside a target element which have 'data-toggle-trigger-off' attribute.
   * @param {node} targetElement - An element targeted by the trigger element
   * @param {node} triggerElement - The trigger element
   * @returns {undefined}
   */


  var manageTriggerOff = function manageTriggerOff(targetElement, triggerElement) {
    var triggerOffList = $$(TRIGGER_OFF, targetElement);

    if (triggerOffList.length === 0) {
      return;
    }

    if (triggerElement.isToggleActive) {
      return triggerOffList.forEach(function (triggerOff) {
        triggerOff.targetElement = triggerElement;
        triggerOff.addEventListener("click", triggerOffHandler, false);
      });
    }

    return triggerOffList.forEach(function (triggerOff) {
      triggerOff.removeEventListener("click", triggerOffHandler, false);
    });
  };
  /**
   * Manage attributes and events of targets elements.
   * @param {node} triggerElement - The trigger element
   * @param {string} className - The class name to toggle
   * @param {boolean} onLoadActive - A flag for active by default
   * @returns {undefined}
   */


  var manageTargets = function manageTargets(triggerElement, className, onLoadActive) {
    return retrieveTargets(triggerElement).forEach(function (targetElement) {
      dispatchHook(targetElement, TOGGLE_BEFORE);
      targetElement.isToggleActive = !targetElement.isToggleActive;
      manageAria(targetElement);

      if (onLoadActive && !targetElement.classList.contains(className)) {
        targetElement.classList.add(className);
      }

      if (!onLoadActive) {
        targetElement.classList.toggle(className);
      }

      if (triggerElement.hasAttribute(OUTSIDE)) {
        targetElement.setAttribute(TARGET_STATE, triggerElement.isToggleActive);
      }

      dispatchHook(targetElement, TOGGLE_AFTER);
      manageTriggerOff(targetElement, triggerElement);
    });
  };
  /**
   * Toggle class and aria on trigger and target elements.
   * @param {node} element - The element to toggle state and attributes
   * @returns {undefined}
   */


  var manageToggle = function manageToggle(element) {
    dispatchHook(element, TOGGLE_BEFORE);
    var className = element.getAttribute(CLASS) || "is-active";
    element.isToggleActive = !element.isToggleActive;
    manageAria(element);

    if (!element.hasAttribute(TARGET_ONLY)) {
      element.classList.toggle(className);
    }

    dispatchHook(element, TOGGLE_AFTER);
    manageTargets(element, className, false);
    return manageTriggerOutside(element);
  };
  /**
   * Toggle elements set to be active by default.
   * @param {node} element - The element to activate on page load
   * @returns {undefined}
   */


  var manageActiveByDefault = function manageActiveByDefault(element) {
    var _manageAria;

    dispatchHook(element, TOGGLE_BEFORE);
    var className = element.getAttribute(CLASS) || "is-active";
    element.isToggleActive = true;
    manageAria(element, (_manageAria = {}, _defineProperty(_manageAria, CHECKED, true), _defineProperty(_manageAria, EXPANDED, true), _defineProperty(_manageAria, HIDDEN, false), _defineProperty(_manageAria, SELECTED, true), _manageAria));

    if (!element.hasAttribute(TARGET_ONLY) && !element.classList.contains(className)) {
      element.classList.add(className);
    }

    dispatchHook(element, TOGGLE_AFTER);
    manageTargets(element, className, true);
    return manageTriggerOutside(element);
  };
  /**
   * Toggle elements of a same group.
   * @param {node} element - The element to test if it's in a group
   * @returns {undefined}
   */


  var manageGroup = function manageGroup(element) {
    var groupActiveElements = retrieveGroupActiveElement(element);

    if (groupActiveElements.length === 0) {
      return manageToggle(element);
    }

    if (groupActiveElements.indexOf(element) === -1) {
      groupActiveElements.forEach(manageToggle);
      return manageToggle(element);
    }

    if (groupActiveElements.indexOf(element) !== -1 && !element.hasAttribute(RADIO_GROUP)) {
      return manageToggle(element);
    }
  };
  /**
   * Initialization.
   * @returns {undefined}
   */


  var init = (function () {
    /** Test if there's some trigger */
    if ($$().length === 0) {
      return console.warn("Easy Toggle State is not used: there's no trigger with '".concat(CLASS, "' attribute to initialize."));
    }
    /** Active by default management. */


    $$(IS_ACTIVE).forEach(function (trigger) {
      if (!trigger.hasAttribute(GROUP) && !trigger.hasAttribute(RADIO_GROUP)) {
        return manageActiveByDefault(trigger);
      }

      if (retrieveGroupActiveElement(trigger).length > 0) {
        return console.warn("Toggle group '".concat(trigger.getAttribute(GROUP) || trigger.getAttribute(RADIO_GROUP), "' must not have more than one trigger with '").concat(IS_ACTIVE, "'"));
      }

      return manageActiveByDefault(trigger);
    });
    /** Set specified or click event on each trigger element. */

    $$().forEach(function (trigger) {
      trigger.addEventListener(trigger.getAttribute(EVENT) || "click", function (event) {
        event.preventDefault();
        (trigger.hasAttribute(GROUP) || trigger.hasAttribute(RADIO_GROUP) ? manageGroup : manageToggle)(trigger);
      }, false);
    });
    /** Escape key management. */

    var triggerEscElements = $$(ESCAPE);

    if (triggerEscElements.length > 0) {
      document.addEventListener("keydown", function (event) {
        if (!(event.key === "Escape") && !(event.key === "Esc")) {
          return;
        }

        triggerEscElements.forEach(function (trigger) {
          if (!trigger.isToggleActive) {
            return;
          }

          if (trigger.hasAttribute(RADIO_GROUP)) {
            return console.warn("You can't use '".concat(ESCAPE, "' on a radio grouped trigger"));
          }

          return (trigger.hasAttribute(GROUP) ? manageGroup : manageToggle)(trigger);
        });
      }, false);
    }
    /** Arrows key management. */


    if ($$(ARROWS).length > 0) {
      document.addEventListener("keydown", function (event) {
        var activeElement = document.activeElement;

        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Home", "End"].indexOf(event.key) === -1 || !activeElement.hasAttribute(CLASS) || !activeElement.hasAttribute(ARROWS)) {
          return;
        }

        if (!activeElement.hasAttribute(GROUP) && !activeElement.hasAttribute(RADIO_GROUP)) {
          return console.warn("You can't use '".concat(ARROWS, "' on a trigger without '").concat(GROUP, "' or '").concat(RADIO_GROUP, "'"));
        }

        event.preventDefault();
        var groupList = activeElement.hasAttribute(GROUP) ? $$("".concat(GROUP, "='").concat(activeElement.getAttribute(GROUP), "'")) : $$("".concat(RADIO_GROUP, "='").concat(activeElement.getAttribute(RADIO_GROUP), "'"));
        var newElement = activeElement;

        switch (event.key) {
          case "ArrowUp":
          case "ArrowLeft":
            newElement = groupList.indexOf(activeElement) > 0 ? groupList[groupList.indexOf(activeElement) - 1] : groupList[groupList.length - 1];
            break;

          case "ArrowDown":
          case "ArrowRight":
            newElement = groupList.indexOf(activeElement) < groupList.length - 1 ? groupList[groupList.indexOf(activeElement) + 1] : groupList[0];
            break;

          case "Home":
            newElement = groupList[0];
            break;

          case "End":
            newElement = groupList[groupList.length - 1];
            break;

          default:
        }

        newElement.focus();
        return newElement.dispatchEvent(new Event(newElement.getAttribute(EVENT) || "click"));
      }, false);
    }
  });

  var onLoad = function onLoad() {
    init();
    document.removeEventListener("DOMContentLoaded", onLoad);
  };

  document.addEventListener("DOMContentLoaded", onLoad);
  window.initEasyToggleState = init;

}());
var tabbis = (function () {
	var fn = {};

	var data;
	var types = ['tab', 'pane'];
	var type;
	var groups = [];
	var activeGroups = [];
	var activeChildren = [];
	var activeItems = [];
	var indexGroup;
	var indexItem;
	var memory = [];

	fn.init = function(options) {
		//console.log('init');
		data = options;
		fn.setDefaults();
		fn.setMemory();

		groups['tab'] = document.querySelectorAll(data.tabGroup);
		groups['pane'] = document.querySelectorAll(data.paneGroup);

		for( var groupIndex = 0; groupIndex < groups['tab'].length; groupIndex++ ) {
			var tabItems = groups['tab'][groupIndex].children;

			for( var itemIndex = 0; itemIndex < tabItems.length; itemIndex++ ) {
				tabItems[itemIndex].addEventListener('click', fn.onClick.bind(this, groupIndex, itemIndex), false);

				indexGroup = groupIndex;
				indexItem = itemIndex;

				if(!fn.hasMemory()) continue;
				fn.setNodes(groupIndex, itemIndex);
			}
		}
	};

	fn.onClick = function(groupIndex, itemIndex) {
		//console.log('click');
		fn.setNodes(groupIndex, itemIndex);

		fn.setCallback(indexGroup, indexItem);
	};

	fn.setNodes = function(groupIndex, itemIndex) {
		indexGroup = groupIndex;
		indexItem = itemIndex;

		for( var i = 0; i < types.length; i++ ) {
			type = types[i];

			fn.setActiveGroup();
			fn.setActiveChildren();
			fn.setActiveItems();
			fn.putActiveClass();
		}

		memory[groupIndex] = [];
		memory[groupIndex][itemIndex] = true;

		localStorage.setItem('tabbis', JSON.stringify(memory));
	};

	fn.hasMemory = function() {
		if( typeof memory === 'undefined' ) return;
		if( typeof memory[indexGroup] === 'undefined' ) return;
		if( typeof memory[indexGroup][indexItem] === 'undefined') return;
		if( memory[indexGroup][indexItem] !== true ) return;
		return true;
	};

	fn.setMemory = function() {
		if(localStorage.getItem('tabbis') === null) return;
		if(localStorage.getItem('tabbis').length == 0) return;

		memory = Object.values(JSON.parse(localStorage.getItem('tabbis')));
	};

	fn.putActiveClass = function() {
		for( var i = 0; i < activeChildren[type].length; i++ ) {
			activeChildren[type][i].classList.remove(data[type + 'Active']);
		}

		activeItems[type].classList.add(data[type + 'Active']);
	};

	fn.setDefaults = function() {
		for( var i = 0; i < types.length; i++ ) {
			type = types[i];

			fn.setOption(type + 'Group', '[data-' + type + 's]');
			fn.setOption(type + 'Active', 'active');
		}
	};

	fn.setOption = function(key, value) {
		data = data || [];
		data[key] = data[key] || value;
	};

	fn.setActiveGroup = function() {
		activeGroups[type] = groups[type][indexGroup];
	};

	fn.setActiveChildren = function() {
		activeChildren[type] = activeGroups[type].children;
	};

	fn.setActiveItems = function() {
		activeItems[type] = activeChildren[type][indexItem];
	};

	fn.setCallback = function() {
		if (typeof data.callback === "function") {
			data.callback(activeItems.tab, activeItems.pane);
		}
	};

	fn.reset = function() {
		for( var groupIndex = 0; groupIndex < groups['tab'].length; groupIndex++ ) {
			tabItems = groups['tab'][groupIndex].children;
			paneItems = groups['pane'][groupIndex].children;

			for( var itemIndex = 0; itemIndex < tabItems.length; itemIndex++ ) {
				tabItems[itemIndex].classList.remove(data['tabActive']);
				paneItems[itemIndex].classList.remove(data['paneActive']);
			}
		}
		localStorage.removeItem('tabbis');
	};
	
	return fn;
})();
/**
* @fileOverview
* @author Zoltan Toth
* @version 2.1.1
*/

/**
* @description
* Vanilla JavaScript dropdown - a tiny (~600 bytes gzipped) select tag replacement.
*
* @class
* @param {(string|Object)} options.elem - HTML id of the select or the DOM element.
*/
var CustomSelect = function(options) {
  var elem          = typeof options.elem === 'string' ?
                        document.getElementById(options.elem) : options.elem,
      mainClass     = 'js-Dropdown',
      titleClass    = 'js-Dropdown-title',
      listClass     = 'js-Dropdown-list',
      selectedClass = 'is-selected',
      openClass     = 'is-open',
      selectOptions = elem.querySelectorAll('option'),
      optionsLength = selectOptions.length;

  // creating the pseudo-select container
  var selectContainer = document.createElement('div');

  selectContainer.className = mainClass;

  if (elem.id) {
    selectContainer.id = 'custom-' + elem.id;
  }

  // creating the always visible main button
  var button = document.createElement('button');

  button.className = titleClass;
  button.textContent = selectOptions[0].textContent;

  // creating the UL
  var ul = document.createElement('ul');
  ul.className = listClass;

  for (var i = 0; i < optionsLength; i++) {
      var li = document.createElement('li');

      li.innerText = selectOptions[i].textContent;
      li.setAttribute('data-value', selectOptions[i].value);
      li.setAttribute('data-index', i);

      if (selectOptions[i].getAttribute('selected') !== null) {
          li.classList.add(selectedClass);
          button.textContent = selectOptions[i].textContent;
      }

      ul.appendChild(li);
  }

  // appending the button and the list
  selectContainer.appendChild(button);
  selectContainer.appendChild(ul);

  selectContainer.addEventListener('click', onClick);

  // pseudo-select is ready - append it and hide the original
  elem.parentNode.insertBefore(selectContainer, elem);
  elem.style.display = 'none';


  /**
  * Closes the current select on any click outside of it.
  *
  */
  document.addEventListener('click', function(e) {
      if (!selectContainer.contains(e.target)) close();
  });

  /**
  * Handles the clicks on current select.
  *
  * @param {object} e - The item the click occured on.
  */
  function onClick(e) {
      e.preventDefault();

      var t = e.target; // || e.srcElement; - uncomment for IE8

      if (t.className === titleClass) {
          toggle();
      }

      if (t.tagName === 'LI') {
          selectContainer.querySelector('.' + titleClass).innerText = t.innerText;
          elem.options.selectedIndex = t.getAttribute('data-index');

          //trigger 'change' event
          var evt = new CustomEvent('change');
          elem.dispatchEvent(evt);

          // highlight the selected
          for (var i = 0; i < optionsLength; i++) {
              ul.querySelectorAll('li')[i].classList.remove(selectedClass);
          }
          t.classList.add(selectedClass);

          close();
      }
  }

  /**
  * Toggles the open/close state of the select on title's clicks.
  *
  * @public
  */
  function toggle() {
      ul.classList.toggle(openClass);
  }

  /**
  * Opens the select.
  *
  * @public
  */
  function open() {
      ul.classList.add(openClass);
  }

  /**
  * Closes the select.
  *
  * @public
  */
  function close() {
      ul.classList.remove(openClass);
  }

  return {
      toggle: toggle,
      close:  close,
      open:   open
  };
};